schema:
  description: 默认 OpenSpec 工作流 - 提案 → 规范 → 设计 → 任务
artifacts:
  proposal:
    description: 概述变更的初始提案文档
    instruction: |
      创建建立"为什么"需要此变更的提案文档。

      部分：
      - **为什么**：关于问题或机会的 1-2 句话。这个问题解决了什么？为什么是现在？
      - **变更内容**：变更列表。对新功能、修改或删除保持具体。用 **BREAKING** 标记破坏性更改。
      - **能力**：识别将创建或修改哪些规范：
        - **新能力**：正在引入的能力列表。每个创建一个新的 `specs/<name>/spec.md`。使用短横线分隔的名称（例如 `user-auth`、`data-export`）。
        - **已修改能力**：其 REQUIREMENTS 正在改变的现有能力。仅在规范级别的行为改变时包括（不仅仅是实现细节）。每个都需要增量规范文件。检查 `openspec/specs/` 中的现有规范名称。如果需求没有变化，留空。
      - **影响**：受影响的代码、API、依赖项或系统。

      **重要**：能力部分很关键。它在提案和规范阶段之间创建契约。填写之前请研究现有规范。
      这里列出的每个能力都需要相应的规范文件。

      保持简洁（1-2 页）。专注于"为什么"而不是"如何"——实施细节属于 design.md。

      这是基础 - 规范、设计和任务都建立在此基础上。

  specs:
    description: 变更的详细规范
    instruction: |
      创建定义系统应该"做什么"的规范文件。

      每个能力/功能区域在 specs/<name>/spec.md 创建一个规范文件。

      增量操作（使用 ## 标题）：
      - **ADDED Requirements**：新能力
      - **MODIFIED Requirements**：更改的行为——必须包含完整的更新内容
      - **REMOVED Requirements**：弃用的功能——必须包含 **原因** 和 **迁移**
      - **RENAMED Requirements**：仅名称更改——使用 FROM:/TO: 格式

      格式化需求：
      - 每个需求：`### Requirement: <name>` 后跟描述
      - 对规范性需求使用 SHALL/MUST（避免 should/may）
      - 每个场景：`#### Scenario: <name>` 使用 WHEN/THEN 格式
      - **关键**：场景必须精确使用 4 个井号（`####`）。使用 3 个井号或项目符号会静默失败。
      - 每个需求必须至少有一个场景。

      MODIFIED 需求工作流：
      1. 在 openspec/specs/<capability>/spec.md 中找到现有需求
      2. 复制**整个**需求块（从 `### Requirement:` 到所有场景）
      3. 粘贴到 `## MODIFIED Requirements` 下并编辑以反映新行为
      4. 确保标题文本完全匹配（忽略空白）

      常见陷阱：使用包含部分内容的 MODIFIED 会在归档时丢失细节。
      如果在不更改现有行为的情况下添加新关注点，请改用 ADDED。

      示例：
      ```
      ## ADDED Requirements

      ### Requirement: 用户可以导出数据
      系统应允许用户以 CSV 格式导出其数据。

      #### Scenario: 成功导出
      - **WHEN** 用户点击"导出"按钮
      - **THEN** 系统下载包含所有用户数据的 CSV 文件

      ## REMOVED Requirements

      ### Requirement: 旧版导出
      **原因**：被新的导出系统取代
      **迁移**：使用新的导出端点 /api/v2/export
      ```

      规范应该是可测试的——每个场景都是一个潜在的测试用例。

  design:
    description: 包含实施细节的技术设计文档
    instruction: |
      创建解释"如何"实施变更的设计文档。

      何时包含 design.md（仅在以下任一情况适用时创建）：
      - 跨领域更改（多个服务/模块）或新架构模式
      - 新外部依赖或重大数据模型更改
      - 安全、性能或迁移复杂性
      - 在编码前受益于技术决策的歧义

      部分：
      - **背景**：背景、当前状态、约束、利益相关者
      - **目标 / 非目标**：这个设计实现什么和明确排除什么
      - **决策**：关键技术选择及理由（为什么是 X 而不是 Y？）。包括每个决策考虑的替代方案。
      - **风险 / 权衡**：已知的限制、可能出错的事情。格式：[风险] → 缓解措施
      - **迁移计划**：部署步骤、回滚策略（如果适用）
      - **开放问题**：待解决的未决决策或未知因素

      专注于架构和方法，而不是逐行实施。
      参考提案了解动机，参考规范了解需求。

      好的设计文档解释技术决策背后的"为什么"。

  tasks:
    description: 从规范和设计派生出的实施任务
    instruction: |
      创建分解实施工作的任务列表。

      指南：
      - 在 ## 编号标题下将相关任务分组
      - 每个任务是一个复选框：- [ ] X.Y 任务描述
      - 任务应该小到可以在一个会话中完成
      - 按依赖排序任务（什么必须先做？）

      示例：
      ```
      ## 1. 设置

      - [ ] 1.1 创建新的模块结构
      - [ ] 1.2 将依赖添加到 package.json

      ## 2. 核心实施

      - [ ] 2.1 实现数据导出功能
      - [ ] 2.2 添加 CSV 格式化工具
      ```

      参考规范了解需要构建什么，设计了解如何构建。
      每个任务应该是可验证的——你知道什么时候完成。
